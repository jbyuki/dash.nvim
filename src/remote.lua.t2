;;; dash
;; implement
function M.connect(port)
  ; disconnect any previous connection
  ; connect to socket
end

;; script variables
local remote

;; connect to socket
remote = vim.fn.sockconnect("tcp", ("localhost:%d"):format(port), { rpc = true })

;; disconnect any previous connection
if remote then
  vim.fn.chanclose(remote)
  remote = nil
end

;; implement
function M.get_output()
  return output_lines
end

;; script variables
local finished = true

;; set as not finished
finished = false

;; set as finished
finished = true

;; implement
function M.has_finished()
  return finished
end

;; implement
function M.execute_remote(filename, ft, open_split)
  local buf
  ; close split if different tabpage
  ; create split if none
  ; save split size

  ; grey namespace

  ; restore split size if quickfix close

  ; clear all highlight
  ; put grey highlight over

  ; execute on remote
  ; register looping request to remote
end

;; execute on remote
-- give relative path to avoid
-- inter-OS path troubles
-- assumption: both the client and server are
-- runing in the same directory
filename = vim.fn.fnamemodify(filename, ":.")
vim.fn.rpcnotify(remote, "nvim_exec_lua", [[require"dash".execute(...)]], { filename, ft, true })

;; register looping request to remote
local timer = vim.loop.new_timer()
timer:start(100, 200, vim.schedule_wrap(function()
  ; update output lines
  ; check if execution finished
end))

;; check if execution finished
local finished = vim.fn.rpcrequest(remote, "nvim_exec_lua", [[return require"dash".has_finished()]], {})
if finished then
  ; clear grey highlight
  timer:close()
end

;; update output lines
local remote_lines = vim.fn.rpcrequest(remote, "nvim_exec_lua", [[return require"dash".get_output()]], {})
vim.api.nvim_buf_set_lines(buf, 0, -1, true, remote_lines)
